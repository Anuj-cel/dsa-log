3844. Longest Almost-Palindromic Substring

From Weekly Contest 489

ğŸ” Problem Understanding

A substring is almost-palindromic if:

You remove exactly one character

The remaining string becomes a palindrome

ğŸ‘‰ So we must:

Choose a substring

Remove one character

Check if what's left is a palindrome

Return the maximum possible length of such a substring.

ğŸ’¡ Key Idea (Greedy + Expand Around Center)

Since palindrome problems usually use:

â€œFix center â†’ expand outwardâ€

We do the same here, but with one allowed skip.

For every center:

Try expanding normally

On first mismatch:

Try skipping left character

Try skipping right character

Continue expanding

Track maximum length

We must check:

Odd-length centers

Even-length centers

ğŸ§© Why This Works

For any substring:

If removing one character makes it palindrome,
then while expanding from center, youâ€™ll encounter:

Either perfect matches

Or exactly one mismatch

At that mismatch:

Skip left OR skip right

Continue expanding

If more than one mismatch occurs â†’ invalid

â± Complexity

We check n centers

Each expansion is O(n)

Total = O(nÂ²)

Works for n â‰¤ 2500

âœ… Clean Implementation (Contest Format)
class Solution {
public:
    int almostPalindromic(string s) {
        int n = s.size();
        int ans = 2;  // minimum valid length
        
        for(int i = 0; i < n; i++) {
            
            // ---------- ODD LENGTH ----------
            
            // Skip left
            int l = 1, skip = 1;
            for(int j = i-1, k = i+1; j >= 0 && k < n; j--, k++) {
                if(s[j] == s[k]) {
                    l += 2;
                } 
                else if(skip) {
                    j++;      // undo j--
                    l++;      
                    skip--;
                } 
                else break;
            }
            ans = max(ans, l);
            
            // Skip right
            l = 1;
            skip = 1;
            for(int j = i-1, k = i+1; j >= 0 && k < n; j--, k++) {
                if(s[j] == s[k]) {
                    l += 2;
                } 
                else if(skip) {
                    k--;      // undo k++
                    l++;
                    skip--;
                } 
                else break;
            }
            ans = max(ans, l);
            
            
            // ---------- EVEN LENGTH ----------
            
            // Skip left
            l = 0;
            skip = 1;
            for(int j = i, k = i+1; j >= 0 && k < n; j--, k++) {
                if(s[j] == s[k]) {
                    l += 2;
                } 
                else if(skip) {
                    j++;
                    l++;
                    skip--;
                } 
                else break;
            }
            ans = max(ans, l);
            
            
            // Skip right
            l = 0;
            skip = 1;
            for(int j = i, k = i+1; j >= 0 && k < n; j--, k++) {
                if(s[j] == s[k]) {
                    l += 2;
                } 
                else if(skip) {
                    k--;
                    l++;
                    skip--;
                } 
                else break;
            }
            ans = max(ans, l);
        }
        
        return ans;
    }
};

ğŸ§  Example Walkthrough
Example: "abca"

Center at b

Compare:

a   c


Mismatch.

Try:

Skip left â†’ remove 'a'

Skip right â†’ remove 'c'

Skipping c gives "aba" â†’ palindrome âœ…

Length = 4

ğŸ¯ Why Many Got TLE

Common mistakes:

Trying all substrings â†’ O(nÂ³)

Checking palindrome after removing each char â†’ O(nÂ³)

Using recursion without pruning

The greedy center-expansion approach keeps it O(nÂ²).

ğŸ Final Thoughts

This problem:

Looks like normal palindrome

But â€œexactly one removalâ€ makes it tricky

Requires careful pointer handling

Classic contest brain-bender ğŸ˜…

If you want, I can also show a cleaner refactored version using a helper function to reduce repetition.
