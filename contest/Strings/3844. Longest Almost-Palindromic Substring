3844. Longest Almost-Palindromic Substring
From Weekly Contest 489
link: https://leetcode.com/problems/longest-almost-palindromic-substring/description/

Problem Understanding
Example 1:

Input: s = "abca"

Output: 4

Explanation:

Choose the substring "abca".

    Remove "abca".
    The string becomes "aba", which is a palindrome.
    Therefore, "abca" is almost-palindromic.



Key Idea 
“Fix center → expand outward”

On first mismatch:
Try skipping left character
Try skipping right character
Continue expanding
Track maximum length
We must check:
Odd-length centers
Even-length centers

Total = O(n²)
Works for n ≤ 2500

Error in thinking:
1. I was doing && instead of || it fails as when mismatch is at corner && fails so in code we only match when both i and j are in range and increase 2 and if 
skip is there increase one and decrease skip --good approach from atmost palindrome problem 
2. I was doing j-- for left shift ,see for left shift we have to skip the current left character for that do k-- so when in next iteration j--,k++ 
happen we have bypassed left character == good one

Code
class Solution {
public:
    int almostPalindromic(string s) {
        int ans=2;
        int n=s.size();
        for(int i=0;i<n;i++)
        {
            int l=1,skip=1;
            //odd length
            for(int j=i-1,k=i+1;j>=0||k<n;j--,k++)
            {
                if(j>=0 && k<n && s[j]==s[k])
                {
                l+=2;
                }else if(skip)j++,l++,skip--;//skip right
                else break;
            }
            ans=max(ans,l);l=1;skip=1;
            for(int j=i-1,k=i+1;j>=0||k<n;j--,k++)
            {
                if(j>=0 && k<n &&s[j]==s[k])l+=2;
                else if(skip)k--,l++,skip--;//skip left
                else break;
            }
            ans=max(ans,l);
            //even length
            l=0;
            skip=1;
            for(int j=i,k=i+1;j>=0||k<n;j--,k++)
            {
                if(j>=0 && k<n &&s[j]==s[k])l+=2;
                else if(skip)j++,l++,skip--;// skip right
                else break;
            }
           
            ans=max(ans,l);
            skip=1;
            l=0;
            for(int j=i,k=i+1;j>=0||k<n;j--,k++)
            {
                if(j>=0 && k<n &&s[j]==s[k])l+=2;
                else if(skip)k--,l++,skip--;//skip left
                else break;
            }
            
            ans=max(ans,l);
        }
        return ans;
    }
};
If you want, I can also show a cleaner refactored version using a helper function to reduce repetition.
